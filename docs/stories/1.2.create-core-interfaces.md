# Story 1.2: Create Core Interfaces and Types

---

## Status

**Draft**

---

## Story

**As a** developer,  
**I want** des interfaces claires pour tous les modules principaux,  
**so that** je peux implémenter les modules de façon découplée et testable.

---

## Acceptance Criteria

1. Interface `IDetector` définie (detect, canHandle, priority)
2. Interface `IFraudDetectionRepository` définie (CRUD operations)
3. Interface `IContextBuilderService` définie (build, buildParallel)
4. Interface `IScoringStrategy` définie (aggregate, calculate)
5. Types core réorganisés dans `lib/fraud-detection-v2/core/types.ts` (< 200 lignes)
6. Branded types créés (`OrganizationId`, `PaymentIntentId`, `CustomerId`)
7. JSDoc complet pour toutes interfaces

**Integration Verification** :
- IV1: Types existants (`lib/fraud-detection/types.ts`) restent inchangés temporairement
- IV2: Nouveau code utilise nouveaux types, ancien code utilise anciens types
- IV3: Aucune compilation error introduite

---

## Tasks / Subtasks

- [ ] **Task 1: Create Core Interfaces** (AC: 1-4, 7)
  - [ ] Create `lib/fraud-detection-v2/core/interfaces.ts`
  - [ ] Define `IDetector` interface with JSDoc
  - [ ] Define `IFraudDetectionRepository` interface with JSDoc
  - [ ] Define `IContextBuilderService` interface with JSDoc
  - [ ] Define `IScoringStrategy` interface with JSDoc
  - [ ] Define `IWebhookHandler` interface with JSDoc
  - [ ] Define `ICacheService` interface with JSDoc

- [ ] **Task 2: Create Core Types** (AC: 5, 6)
  - [ ] Create `lib/fraud-detection-v2/core/types.ts`
  - [ ] Define branded types (`OrganizationId`, `PaymentIntentId`, `CustomerId`)
  - [ ] Define `DetectorResult` type
  - [ ] Define `FraudDetectionResult` type (V2 compatible with V1)
  - [ ] Define `TransactionContext` type (V2 compatible with V1)
  - [ ] Ensure file < 200 lines

- [ ] **Task 3: Verify Compilation** (AC: IV3)
  - [ ] Run `bun run build` to verify no compilation errors
  - [ ] Verify existing code still compiles (no breaking changes)
  - [ ] Run linter: `bun run lint`

---

## Dev Notes

### Relevant Architecture Information

**From `docs/architecture.md` - Component Architecture** :

**IDetector Interface** :
```typescript
export interface IDetector {
  name: string;
  priority: number;              // 1 = highest, 100 = lowest
  canHandle(context: TransactionContext): boolean;
  detect(context: TransactionContext): Promise<DetectorResult>;
}

export interface DetectorResult {
  detectorName: string;
  factors: FraudFactor[];        // Risk factors identifiés
  score: number;                  // Score de ce detector (0-100)
  confidence: number;             // Confiance (0-1)
  metadata?: Record<string, unknown>;
}
```

**IFraudDetectionEngine Interface** :
```typescript
export interface IFraudDetectionEngine {
  detect(context: TransactionContext): Promise<FraudDetectionResult>;
  registerDetector(detector: IDetector): void;
  setScoringStrategy(strategy: IScoringStrategy): void;
}
```

**IContextBuilderService Interface** :
```typescript
export interface IContextBuilderService {
  build(paymentIntent: Stripe.PaymentIntent, organizationId: string): Promise<TransactionContext>;
  buildParallel(paymentIntent: Stripe.PaymentIntent, organizationId: string): Promise<TransactionContext>;
}

export interface IContextProvider<T> {
  canProvide(paymentIntent: Stripe.PaymentIntent): boolean;
  provide(paymentIntent: Stripe.PaymentIntent, organizationId: string): Promise<T>;
}
```

**IWebhookHandler Interface** :
```typescript
export interface IWebhookHandler {
  canHandle(event: Stripe.Event): boolean;
  handle(event: Stripe.Event, organizationId: string): Promise<WebhookHandlerResult>;
}

export interface WebhookHandlerResult {
  success: boolean;
  message?: string;
  data?: unknown;
  error?: Error;
}
```

**ICacheService Interface** :
```typescript
export interface ICacheService {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T, ttl: number): Promise<void>;
  invalidate(key: string): Promise<void>;
  invalidatePattern(pattern: string): Promise<void>;
}
```

### Coding Standards

**From Architecture - Enhancement-Specific Standards** :

**Standard 1: Dependency Injection Obligatoire**
- All services must use constructor injection
- Interfaces defined before implementations

**Standard 2: Interface-First Design**
- Define interfaces before implementations
- All public APIs must have interfaces

**Standard 3: JSDoc Complet**
```typescript
/**
 * Détecte la fraude pour une transaction donnée via pipeline modulaire.
 * 
 * @param context - Context complet de la transaction
 * @returns Résultat de détection avec décision, score, et facteurs
 * @throws {FraudDetectionError} Si erreur critique pendant détection
 * 
 * @example
 * ```typescript
 * const result = await engine.detect(transactionContext);
 * if (result.decision === 'BLOCK') {
 *   await blockPayment(paymentIntent.id);
 * }
 * ```
 */
async detect(context: TransactionContext): Promise<FraudDetectionResult>;
```

### Source Tree

**New Files to Create** :
```
lib/
  └── fraud-detection-v2/
      └── core/
          ├── interfaces.ts      # All interfaces (IDetector, IEngine, etc.)
          └── types.ts           # Core types (< 200 lines)
```

**Existing Files (DO NOT MODIFY)** :
- `lib/fraud-detection/types.ts` - Legacy types (keep unchanged)
- `lib/fraud-detection/engine.ts` - Legacy engine (keep unchanged)

### Branded Types Pattern

```typescript
// Branded types for type safety
export type OrganizationId = string & { readonly __brand: 'OrganizationId' };
export type PaymentIntentId = string & { readonly __brand: 'PaymentIntentId' };
export type CustomerId = string & { readonly __brand: 'CustomerId' };

// Helper functions
export const toOrganizationId = (id: string): OrganizationId => id as OrganizationId;
export const toPaymentIntentId = (id: string): PaymentIntentId => id as PaymentIntentId;
export const toCustomerId = (id: string): CustomerId => id as CustomerId;
```

### Testing Standards

**Test File Location** : `lib/fraud-detection-v2/core/__tests__/`

**Test Requirements** :
- Verify interfaces compile correctly
- Verify branded types work as expected
- Verify no compilation errors with existing code

---

## Testing

### Test Requirements for This Story

**Unit Tests** :
- Test branded type helpers (toOrganizationId, etc.)
- Test that interfaces can be implemented
- Verify TypeScript compilation

**Integration Tests** :
- Verify existing code still compiles
- Verify no breaking changes introduced

**Acceptance** :
- All 7 acceptance criteria met
- JSDoc complete for all interfaces
- File size < 200 lines for types.ts
- No compilation errors

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-08 | 1.0 | Story created from PRD | Sarah (PO) |

---

## Dev Agent Record

_This section will be populated by the development agent during implementation._

---

## QA Results

_This section will be populated by QA Agent after story completion._

---
