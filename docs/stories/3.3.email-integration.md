# Story 3.3: Email Integration into Webhook Handlers

---

## Status

Draft

---

## Story

**As a** webhook handler,
**I want** to automatically send email alerts when critical fraud events occur,
**so that** merchants are immediately notified of threats and can take action.

---

## Acceptance Criteria

1. Integrate `sendAlertEmail()` call into `stripe-webhook-handlers.ts` after creating critical alerts
2. Email sent only for alerts with `severity === "critical"`
3. Add `emailSentAt` field to `alerts` table schema (migration required)
4. Update `alerts.emailSentAt` timestamp after successful email send
5. Log email send attempts (success and failure) without blocking webhook processing
6. Handle email failures gracefully - webhook continues even if email fails
7. Integration tests verify complete flow: webhook → alert → email sent → DB updated
8. Existing webhook functionality unchanged (no regression)

---

## Tasks / Subtasks

- [ ] Add `emailSentAt` field to alerts schema (AC: 3)
  - [ ] Modify `lib/db/schemas/alerts.ts`:
    - Add field: `emailSentAt: timestamp("email_sent_at")`
  - [ ] Generate migration: `bun run db:generate`
  - [ ] Review generated migration SQL
  - [ ] Run migration: `bun run db:migrate`
  - [ ] Verify field added in Drizzle Studio

- [ ] Integrate email sending in BLOCK alert handler (AC: 1, 2, 5, 6)
  - [ ] Locate BLOCK alert creation in `stripe-webhook-handlers.ts` ligne ~355
  - [ ] Import `sendAlertEmail` from `lib/actions/send-alert-email.ts`
  - [ ] After alert created, check if `severity === "critical"`
  - [ ] If critical, call `sendAlertEmail()` in try-catch block
  - [ ] Wrap in async but don't await (non-blocking)
  - [ ] Log success or failure
  - [ ] Continue webhook processing regardless of email result

- [ ] Integrate email sending in card testing alert handler (AC: 1, 2, 5, 6)
  - [ ] Locate card testing alert creation in `stripe-webhook-handlers.ts` ligne ~534
  - [ ] Same pattern as BLOCK handler:
    - Check `severity === "critical"`
    - Call `sendAlertEmail()` in try-catch
    - Non-blocking (don't await in main flow)
    - Log result

- [ ] Update alerts table after email sent (AC: 4)
  - [ ] In email send success callback, update alert:
    ```typescript
    await db.update(alerts)
      .set({ emailSentAt: new Date() })
      .where(eq(alerts.id, alertId));
    ```
  - [ ] Only update if email send was successful
  - [ ] Log DB update errors but don't throw

- [ ] Implement graceful error handling (AC: 6)
  - [ ] Wrap all email logic in try-catch
  - [ ] Log email errors with structured logging: `logger.error("Failed to send alert email", { alertId, error })`
  - [ ] Do NOT throw errors (webhook must complete)
  - [ ] Create internal alert for failed email sends (monitoring)

- [ ] Write integration tests (AC: 7)
  - [ ] Test complete flow: webhook event → alert created → email sent → `emailSentAt` updated
  - [ ] Mock `sendAlertEmail()` to return success
  - [ ] Verify email function called with correct alert ID
  - [ ] Verify `emailSentAt` timestamp set in database
  - [ ] Test email failure scenario: webhook completes, `emailSentAt` remains null
  - [ ] Test non-critical alert: email NOT sent

- [ ] Verify no regression (AC: 8)
  - [ ] Run all existing webhook handler tests
  - [ ] Verify alerts still created correctly
  - [ ] Verify fraud detection unchanged
  - [ ] Verify webhook response time acceptable (< 30s)

---

## Dev Notes

### Relevant Source Tree

**Files to Modify:**
- `lib/db/schemas/alerts.ts` - Add `emailSentAt` field
- `lib/actions/stripe-webhook-handlers.ts` - Integrate email sending ligne ~355 and ~534

**Dependencies:**
- Story 3.1 `lib/actions/send-alert-email.ts` - Email sending function
- Story 3.2 `lib/emails/` - Email templates
- `lib/db/schemas/alerts.ts` - Alerts table schema

**Existing Code Context (BLOCK Alert):**
```typescript
// lib/actions/stripe-webhook-handlers.ts ligne ~355
// After fraud detection blocks payment
if (result.decision === "BLOCK") {
  // Cancel payment
  await stripe.paymentIntents.cancel(paymentIntent.id);
  
  // Create alert
  const alert = await db.insert(alerts).values({
    id: crypto.randomUUID(),
    organizationId,
    type: "fraud_detected",
    severity: result.riskScore >= 90 ? "critical" : "high",
    title: "Paiement frauduleux bloqué",
    message: `Paiement de ${paymentIntent.amount / 100}€ bloqué`,
    data: { paymentIntentId: paymentIntent.id, riskScore: result.riskScore },
    isRead: false,
    createdAt: new Date(),
  }).returning();
  
  // ⚠️ ADD EMAIL SENDING HERE ⚠️
  // 1. Check if severity === "critical"
  // 2. Call sendAlertEmail(alert.id, organizationId)
  // 3. Update emailSentAt if successful
  // 4. Log errors, don't throw
}
```

**Email Integration Pattern:**
```typescript
// After alert created
if (alert.severity === "critical") {
  // Non-blocking email send
  setImmediate(async () => {
    try {
      const emailResult = await sendAlertEmail(alert.id, organizationId);
      
      if (emailResult.success) {
        // Update emailSentAt
        await db.update(alerts)
          .set({ emailSentAt: new Date() })
          .where(eq(alerts.id, alert.id));
        
        logger.info("Alert email sent", { alertId: alert.id, emailId: emailResult.emailId });
      } else {
        logger.error("Failed to send alert email", { alertId: alert.id, error: emailResult.error });
      }
    } catch (error) {
      logger.error("Exception sending alert email", { alertId: alert.id, error });
    }
  });
}
```

**Schema Migration:**
```typescript
// lib/db/schemas/alerts.ts
export const alerts = pgTable("alerts", {
  // ... existing fields ...
  emailSentAt: timestamp("email_sent_at"), // NEW FIELD
});
```

**Existing Patterns to Follow:**
- Async operations: Use `setImmediate()` or Promise fire-and-forget pattern for non-blocking
- Error handling: Try-catch with logging, never throw
- Database updates: Use Drizzle `db.update().set().where()`
- Logging: Use `logger` from `lib/logger.ts` with structured data

**Critical Constraints:**
- Email sending MUST NOT block webhook response (Stripe 30s timeout)
- Webhook MUST complete successfully even if email fails
- Only critical alerts trigger emails (`severity === "critical"`)
- Rate limiting is enforced in `sendAlertEmail()` (story 3.1)
- `emailSentAt` only set on successful email send

**Performance Considerations:**
- Email sending is async and non-blocking
- Rate limiting prevents spam (1 email/hour/type/org)
- Database update is separate from webhook response
- Webhook completes in < 30 seconds regardless of email status

### Testing

**Test Framework:** Vitest for integration tests

**Test File Location:** `lib/actions/__tests__/stripe-webhook-handlers.test.ts` (extend existing)

**Testing Standards:**
- Integration tests test complete flow from webhook to email
- Mock `sendAlertEmail()` to avoid actual email sends
- Verify database updates with test database
- Test both success and failure scenarios
- Verify webhook completes quickly (< 30s)

**Test Coverage Requirements:**
- All new code paths covered
- Regression tests for existing webhook functionality
- Test critical and non-critical alerts separately

**Test Scenarios:**
1. Critical BLOCK alert → email sent → `emailSentAt` updated
2. High (non-critical) BLOCK alert → email NOT sent
3. Critical card testing alert → email sent → `emailSentAt` updated
4. Email send fails → error logged → webhook completes → `emailSentAt` null
5. Rate limit exceeded → no email sent → webhook completes
6. Existing webhook tests still pass (no regression)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-08 | 1.0 | Initial story creation for Epic 3 | Sarah (Product Owner) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

---

## QA Results

_To be filled by QA agent_
