# Story 3.3: Add In-Memory Cache for Stable Data

---

## Status

**Draft**

---

## Story

**As a** system,  
**I want** cacher les données stables (custom rules, customer scores),  
**so that** les DB queries répétitives sont éliminées et latence réduite.

---

## Acceptance Criteria

1. `CacheService` créé avec interface `ICacheService` (get, set, invalidate)
2. In-memory cache implementation (Node.js Map avec TTL)
3. Cache pour :
   - Custom rules (TTL: 60s)
   - Customer trust scores (TTL: 5min)
   - Velocity metrics (PAS de cache - trop volatile)
4. Event-based invalidation (dispute.created, rule.updated)
5. Cache hit/miss metrics logged
6. **Performance** : 20-30% réduction queries DB

**Integration Verification** :
- IV1: Cache miss = fetch DB (transparent fallback)
- IV2: Conservative TTLs empêchent stale data
- IV3: Event invalidation testée (updates propagent)
- IV4: Monitoring cache hit rate (target > 70%)

**Rollback Considerations** :
- Feature flag `ENABLE_CACHE` pour activer/désactiver
- Cache disabled par défaut en dev/staging (testing)
- Automatic invalidation si stale data détectée

---

## Tasks / Subtasks

- [ ] **Task 1: Create CacheService** (AC: 1, 2)
  - [ ] Create `lib/fraud-detection-v2/services/cache.service.ts`
  - [ ] Implement `ICacheService` interface
  - [ ] Use Node.js Map for in-memory storage
  - [ ] Implement TTL logic

- [ ] **Task 2: Integrate Cache** (AC: 3)
  - [ ] Cache custom rules (TTL: 60s)
  - [ ] Cache customer trust scores (TTL: 5min)
  - [ ] Do NOT cache velocity metrics

- [ ] **Task 3: Event-Based Invalidation** (AC: 4)
  - [ ] Listen to `dispute.created` event
  - [ ] Listen to `rule.updated` event
  - [ ] Invalidate relevant cache entries

- [ ] **Task 4: Add Metrics** (AC: 5)
  - [ ] Log cache hits
  - [ ] Log cache misses
  - [ ] Calculate hit rate

---

## Dev Notes

### Integration Points (Where Cache is Used)

**1. Custom Rules Cache** (injected in `CustomRulesDetector`)

**Integration Point** : `lib/fraud-detection-v2/detectors/custom-rules.detector.ts`
```typescript
export class CustomRulesDetector implements IDetector {
  constructor(
    private cacheService: ICacheService,
    private db: Database
  ) {}

  async detect(context: TransactionContext): Promise<DetectorResult> {
    const cacheKey = `custom-rules:${context.organizationId}`;
    
    // Try cache first
    let rules = await this.cacheService.get<FraudDetectionRule[]>(cacheKey);
    
    if (!rules) {
      // Cache miss - fetch from DB
      rules = await this.db.query.fraudDetectionRules.findMany({
        where: and(
          eq(fraudDetectionRules.organizationId, context.organizationId),
          eq(fraudDetectionRules.enabled, true)
        ),
      });
      
      // Cache for 60 seconds
      await this.cacheService.set(cacheKey, rules, 60);
    }
    
    // Apply rules logic...
  }
}
```

**2. Customer Trust Score Cache** (injected in `TrustScoreDetector`)

**Integration Point** : `lib/fraud-detection-v2/detectors/trust-score.detector.ts`
```typescript
export class TrustScoreDetector implements IDetector {
  constructor(private cacheService: ICacheService) {}

  async detect(context: TransactionContext): Promise<DetectorResult> {
    const customerId = context.customer.id;
    const cacheKey = `trust-score:${customerId}`;
    
    // Try cache first
    let trustScore = await this.cacheService.get<TrustScoreResult>(cacheKey);
    
    if (!trustScore) {
      // Cache miss - calculate from metrics
      trustScore = calculateTrustScore(context.customer.metrics);
      
      // Cache for 5 minutes (300 seconds)
      await this.cacheService.set(cacheKey, trustScore, 300);
    }
    
    // Transform to DetectorResult...
  }
}
```

**3. Velocity Metrics** (NO CACHE - too volatile)

**Velocity data is NEVER cached** because it changes rapidly (e.g., new payment every few seconds).

### Event-Based Invalidation Strategy

**Where Events are Captured** : Webhook handlers trigger cache invalidation

**Invalidation Point 1** : `dispute.created` event (in `charge.handlers.ts`)
```typescript
// lib/webhook-handlers-v2/handlers/charge.handlers.ts
export async function handleDisputeCreated(
  event: Stripe.Event,
  connection: StripeConnection
) {
  const dispute = event.data.object as Stripe.Dispute;
  
  // 1. Process dispute logic...
  
  // 2. Invalidate customer trust score cache
  const customerId = dispute.charge?.customer;
  if (customerId) {
    await cacheService.invalidate(`trust-score:${customerId}`);
  }
}
```

**Invalidation Point 2** : `rule.updated` event (internal API)
```typescript
// lib/actions/fraud-rules.ts (Server Action)
export async function updateFraudRule(ruleId: string, data: UpdateRuleData) {
  const rule = await db.update(fraudDetectionRules)
    .set(data)
    .where(eq(fraudDetectionRules.id, ruleId))
    .returning();
  
  // Invalidate custom rules cache for organization
  await cacheService.invalidate(`custom-rules:${rule[0].organizationId}`);
  
  return rule[0];
}
```

**Invalidation Point 3** : Pattern-based invalidation
```typescript
// Invalidate all trust scores for an organization
await cacheService.invalidatePattern(`trust-score:${organizationId}:*`);
```

### Cache Key Naming Strategy

**Pattern** : `{resource}:{identifier}[:{subidentifier}]`

**Examples** :
```typescript
// Custom Rules
`custom-rules:${organizationId}`           // All rules for org
`custom-rules:${organizationId}:${ruleId}` // Specific rule

// Trust Scores
`trust-score:${customerId}`                // Customer trust score
`trust-score:${organizationId}:${customerId}` // Org-scoped score

// Customer Metrics (if cached)
`customer-metrics:${customerId}`           // Customer metrics

// Velocity (NOT cached, but shown for reference)
`velocity:${organizationId}:${customerId}` // Would be too volatile
```

**Benefits of this pattern** :
- Easy to invalidate all related keys (`custom-rules:*`)
- Clear resource identification
- Multi-tenant isolation (organizationId in key)

### Cache Service Example

```typescript
export class CacheService implements ICacheService {
  private cache: Map<string, { value: any; expiresAt: number }> = new Map();

  async get<T>(key: string): Promise<T | null> {
    const entry = this.cache.get(key);
    if (!entry) return null;
    
    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.value as T;
  }

  async set<T>(key: string, value: T, ttl: number): Promise<void> {
    this.cache.set(key, {
      value,
      expiresAt: Date.now() + ttl * 1000,
    });
  }

  async invalidate(key: string): Promise<void> {
    this.cache.delete(key);
  }

  async invalidatePattern(pattern: string): Promise<void> {
    // Convert glob pattern to regex
    const regex = new RegExp(
      "^" + pattern.replace(/\*/g, ".*").replace(/\?/g, ".") + "$"
    );
    
    // Delete all matching keys
    for (const key of this.cache.keys()) {
      if (regex.test(key)) {
        this.cache.delete(key);
      }
    }
  }
}
```

---

## Testing

**Acceptance** :
- All 6 acceptance criteria met
- 20-30% reduction in DB queries
- Cache hit rate > 70%
- Event invalidation works

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-08 | 1.0 | Story created from PRD | Sarah (PO) |

---
